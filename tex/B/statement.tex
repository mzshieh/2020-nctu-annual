The Prüfer code of a labeled tree is a unique sequence associate with the tree.
Assume that $T$ is a labeled tree of $n$ ($n\ge 2$) vertices, and the vertices of $T$ 
are labeled $1,2,\ldots n$.
The Prüfer code for $T$ has length $n-2$ and 
can be generated by the following procedure:
\begin{enumerate}
\tightlist
\item Initialize \verb+arr+ as an empty list.
\item Repeat the following steps until $T$ has two or less vertices.
\begin{enumerate}
\tightlist
\item Let $x$ be a vertex which has exactly one neighbor. 
      If there are multiple candidates of $x$, 
      then pick the one with minimum index.
\item Append the index of $x$'s neighbor to \verb+arr+.
\item Remove $x$ from $T$.
%\item If $T$ still has more than two vertices, go to step 2.
\end{enumerate}
\end{enumerate}
When the procedure terminated, the sequence stored in \verb+arr+ 
is the Prüfer code of $T$. 
Note that every Prüfer code can be recover to the unique tree.
Therefore, we can represent an $n$-vertex tree with a Prüfer code of length
$n-2$.

Now we use the function \verb+randPruder+ in the following Python code 
to produce a random Prüfer code of an \verb+n+-vertex tree 
where \verb+randint(L,R)+ is a function returning a uniformly random 
number between \verb+L+ and \verb+R+, inclusively.

\begin{verbatim}
from random import randint

fun randPrufer(n):
    arr = []
    for i in range(n-2):
        arr.append(randint(1,n))
    return arr
\end{verbatim}

Let $T_R$ be the labeled tree corresponding to the random Prüfer code 
produced by  \verb+randPrufer(+$n$\verb+)+.
In this problem, a valid vertex coloring of $T_R$ with $c$ colors 
$C_1,C_2,\dots,C_c$ is defined as follows.
\begin{itemize}
\item Every vertex in $T_R$ must be colored in one of $C_1,C_2,\dots,C_c$.
\item Two endpoints of any edge in $T_R$ are not colored in the same color.
\end{itemize}

Please write a program to compute the expected number of ways of valid vertex 
coloring of $T_R$. 
